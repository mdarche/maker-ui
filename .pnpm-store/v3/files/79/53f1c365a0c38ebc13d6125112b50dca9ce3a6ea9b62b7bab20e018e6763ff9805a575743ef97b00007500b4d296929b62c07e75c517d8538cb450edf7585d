{"version":3,"sources":["../../src/query/tabsequence.sort-shadowed.js"],"names":["elements","context","sortElements","shadows","Shadows","_elements","extractElements","length","sort","hostCounter","inHost","inDocument","hosts","host","_sortingId","parentHost","_registerHost","_registerHostParent","push","parent","element","filter","_registerElement","_injectHosts","_replaceHosts","_cleanup","Object","keys","forEach","_list","_context","shadowRoot","_merge","list","merged","resolveElement","_resolveHostElement","bind","_tabindex","concat","key"],"mappings":"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","file":"tabsequence.sort-shadowed.js","sourcesContent":["\nimport getShadowHost from '../get/shadow-host';\nimport mergeInDomOrder from '../util/merge-dom-order';\nimport tabindexValue from '../util/tabindex-value';\n\nclass Shadows {\n  constructor(context, sortElements) {\n    // document context we're working with\n    this.context = context;\n    // callback that sorts an array of elements\n    this.sortElements = sortElements;\n    // reference to create unique IDs for each ShadowHost\n    this.hostCounter = 1;\n    // reference map for child-ShadowHosts of a ShadowHost\n    this.inHost = {};\n    // reference map for child-ShadowHost of the document\n    this.inDocument = [];\n    // reference map for ShadowHosts\n    this.hosts = {};\n    // reference map for tabbable elements of a ShadowHost\n    this.elements = {};\n  }\n\n  // remember which hosts we have to sort within later\n  _registerHost(host) {\n    if (host._sortingId) {\n      return;\n    }\n\n    // make the ShadowHost identifiable (see cleanup() for undo)\n    host._sortingId = 'shadow-' + (this.hostCounter++);\n    this.hosts[host._sortingId] = host;\n\n    // hosts may contain other hosts\n    const parentHost = getShadowHost({context: host});\n    if (parentHost) {\n      this._registerHost(parentHost);\n      this._registerHostParent(host, parentHost);\n    } else {\n      this.inDocument.push(host);\n    }\n  }\n\n  // remember which host is the child of which other host\n  _registerHostParent(host, parent) {\n    if (!this.inHost[parent._sortingId]) {\n      this.inHost[parent._sortingId] = [];\n    }\n\n    this.inHost[parent._sortingId].push(host);\n  }\n\n  // remember which elements a host contains\n  _registerElement(element, host) {\n    if (!this.elements[host._sortingId]) {\n      this.elements[host._sortingId] = [];\n    }\n\n    this.elements[host._sortingId].push(element);\n  }\n\n  // remove shadowed elements from the sequence and register\n  // the ShadowHosts they belong to so we know what to sort\n  // later on\n  extractElements(elements) {\n    return elements.filter(function(element) {\n      const host = getShadowHost({ context: element });\n      if (!host) {\n        return true;\n      }\n\n      this._registerHost(host);\n      this._registerElement(element, host);\n      return false;\n    }, this);\n  }\n\n  // inject hosts into the sequence, sort everything,\n  // and recoursively replace hosts by its descendants\n  sort(elements) {\n    let _elements = this._injectHosts(elements);\n    _elements = this._replaceHosts(_elements);\n    this._cleanup();\n    return _elements;\n  }\n\n  // merge ShadowHosts into the element lists of other ShadowHosts\n  // or the document, then sort the individual lists\n  _injectHosts(elements) {\n    Object.keys(this.hosts).forEach(function(_sortingId) {\n      const _list = this.elements[_sortingId];\n      const _elements = this.inHost[_sortingId];\n      const _context = this.hosts[_sortingId].shadowRoot;\n      this.elements[_sortingId] = this._merge(_list, _elements, _context);\n    }, this);\n\n    return this._merge(elements, this.inDocument, this.context);\n  }\n\n  _merge(list, elements, context) {\n    const merged = mergeInDomOrder({\n      list,\n      elements,\n    });\n\n    return this.sortElements(merged, context);\n  }\n\n  _replaceHosts(elements) {\n    return mergeInDomOrder({\n      list: elements,\n      elements: this.inDocument,\n      resolveElement: this._resolveHostElement.bind(this),\n    });\n  }\n\n  _resolveHostElement(host) {\n    const merged = mergeInDomOrder({\n      list: this.elements[host._sortingId],\n      elements: this.inHost[host._sortingId],\n      resolveElement: this._resolveHostElement.bind(this),\n    });\n\n    const _tabindex = tabindexValue(host);\n    if (_tabindex !== null && _tabindex > -1) {\n      return [host].concat(merged);\n    }\n\n    return merged;\n  }\n\n  _cleanup() {\n    // remove those identifers we put on the ShadowHost to avoid using Map()\n    Object.keys(this.hosts).forEach(function(key) {\n      delete this.hosts[key]._sortingId;\n    }, this);\n  }\n}\n\nexport default function(elements, context, sortElements) {\n  const shadows = new Shadows(context, sortElements);\n  const _elements = shadows.extractElements(elements);\n\n  if (_elements.length === elements.length) {\n    // no shadowed content found, no need to continue\n    return sortElements(elements);\n  }\n\n  return shadows.sort(_elements);\n}\n"]}