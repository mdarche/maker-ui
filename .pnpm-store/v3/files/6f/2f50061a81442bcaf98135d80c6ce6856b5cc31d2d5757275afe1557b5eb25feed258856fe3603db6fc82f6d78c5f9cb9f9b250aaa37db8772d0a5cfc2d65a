{"version":3,"sources":["../../src/util/visible-area.js"],"names":["getParents","getIntersectingRect","one","two","top","Math","max","left","right","min","bottom","width","height","getViewportRect","window","innerWidth","document","documentElement","clientWidth","innerHeight","clientHeight","getInnerBoundingClientRect","element","rect","getBoundingClientRect","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","_rect","area","isOverflowingElement","style","getComputedStyle","value","getPropertyValue","isScrollableElement","scrollHeight","scrollWidth","getScrollableParentRect","scrollingContainers","context","slice","filter","length","reduce","previous","current","intersection","_element","_viewport","_area","_container","_visible","maxArea","visibleArea","round","factor","roundedVisibleArea"],"mappings":"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","file":"visible-area.js","sourcesContent":["\nimport getParents from '../get/parents';\n\nfunction getIntersectingRect(one, two) {\n  // identify the rectangle that _element and _container overlap in\n  const top = Math.max(one.top, two.top);\n  const left = Math.max(one.left, two.left);\n  // make sure bottom can't be above top, right can't be before left\n  const right = Math.max(Math.min(one.right, two.right), left);\n  const bottom = Math.max(Math.min(one.bottom, two.bottom), top);\n  // return something resembling ClientRect\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n\nfunction getViewportRect() {\n  const width = window.innerWidth || document.documentElement.clientWidth;\n  const height = window.innerHeight || document.documentElement.clientHeight;\n  // return something resembling ClientRect\n  return {\n    top: 0,\n    right: width,\n    bottom: height,\n    left: 0,\n    width: width,\n    height: height,\n  };\n}\n\nfunction getInnerBoundingClientRect(element) {\n  // convenience for the .reduce() in getScrollableParentRect()\n  const rect = element.getBoundingClientRect();\n\n  // remove the width of the scrollbar because that\n  // area is not really considered visible\n  // NOTE: assuming scrollbar is always to the right and bottom\n  const scrollbarWidth = element.offsetWidth - element.clientWidth;\n  const scrollbarHeight = element.offsetHeight - element.clientHeight;\n  // cannot mutate rect because it has readonly properties\n  const _rect = {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right - scrollbarWidth,\n    bottom: rect.bottom - scrollbarHeight,\n    width: rect.width - scrollbarWidth,\n    height: rect.height - scrollbarHeight,\n    area: 0,\n  };\n\n  _rect.area = _rect.width * _rect.height;\n  return _rect;\n}\n\nfunction isOverflowingElement(element) {\n  const style = window.getComputedStyle(element, null);\n  const value = 'visible';\n  return style.getPropertyValue('overflow-x') !== value\n    && style.getPropertyValue('overflow-y') !== value;\n}\n\nfunction isScrollableElement(element) {\n  // an element not scrollable if it doesn't crop its content\n  if (!isOverflowingElement(element)) {\n    return false;\n  }\n\n  // an element is scrollable when it is smaller than its content\n  return element.offsetHeight < element.scrollHeight\n    || element.offsetWidth < element.scrollWidth;\n}\n\nfunction getScrollableParentRect(element) {\n  // get largest possible space constrained by scrolling containers\n\n  // find scrollable parents\n  const scrollingContainers = getParents({context: element}).slice(1).filter(isScrollableElement);\n\n  if (!scrollingContainers.length) {\n    // no containers, no joy\n    return null;\n  }\n\n  // identify the currently visible intersection of all scrolling container parents\n  return scrollingContainers.reduce(function(previous, current) {\n    const rect = getInnerBoundingClientRect(current);\n    const intersection = getIntersectingRect(rect, previous);\n    // identify the smallest scrolling container so we know how much space\n    // our element can fill at the most - note that this is NOT the area\n    // of the intersection, intersection is just abused as a vehicle\n    intersection.area = Math.min(rect.area, previous.area);\n    return intersection;\n  }, getInnerBoundingClientRect(scrollingContainers[0]));\n}\n\nexport default function(element) {\n  // dimensions of the element itself\n  const _element = element.getBoundingClientRect();\n  // dimensions of the viewport\n  const _viewport = getViewportRect();\n  // we need the area to know how much of the element can be displayed at the most\n  _viewport.area = _viewport.width * _viewport.height;\n\n  let _area = _viewport;\n  // dimensions of the intersection of all scrollable parents\n  const _container = getScrollableParentRect(element);\n  if (_container) {\n    if (!_container.width || !_container.height) {\n      // scrollable containers without dimensions are invisible,\n      // meaning that the element is not visible at all\n      return 0;\n    }\n\n    // dimension the element can currently be rendered in\n    _area = getIntersectingRect(_container, _viewport);\n    _area.area = _container.area;\n  }\n\n  // dimension of the element currently rendered in identified space\n  const _visible = getIntersectingRect(_element, _area);\n  if (!_visible.width || !_visible.height) {\n    // element is not shown within the identified area\n    return 0;\n  }\n\n  // compare the element's currently visible size to the size it\n  // could take up at the most, being either the element's actual\n  // size, or the space theroetically made available if all\n  // scrollable parents are aligned properly\n  const area = _element.width * _element.height;\n  const maxArea = Math.min(area, _area.area);\n  // Firefox may return sub-pixel bounding client rect\n  const visibleArea = Math.round(_visible.width) * Math.round(_visible.height) / maxArea;\n  // Edge might not reach 0.5 exactly\n  const factor = 10000;\n  const roundedVisibleArea = Math.round(visibleArea * factor) / factor;\n  // clamp the value at 1\n  return Math.min(roundedVisibleArea, 1);\n}\n"]}