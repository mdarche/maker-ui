{"version":3,"sources":["../../src/when/key.binding.js"],"names":["text","split","map","_text","tokens","_modifiers","resolveModifiers","slice","_keyCodes","resolveKey","keyCodes","modifiers","matchModifiers","bind","modifier","alt","ctrl","meta","shift","modifierSequence","Object","keys","name","createExpectedModifiers","ignoreModifiers","value","altKey","ctrlKey","metaKey","shiftKey","indexOf","expected","forEach","token","operator","propertyName","TypeError","key","code","parseInt","isNaN","concat","_alias","event","some","prop","Boolean"],"mappings":"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","file":"key.binding.js","sourcesContent":["\n/*\n  decodes a key binding token to a JavaScript structure\n\n  returns an array of objects:\n    {\n      // key name translated to keyCode (possibly more than one)\n      keyCodes: [<number>],\n      // translated modifiers\n      modifiers: {\n        altKey: null,   // ignore\n        ctrKey: false,  // expect not pressed\n        metaKey: true,  // expect pressed\n        shiftKey: true, // expect pressed\n      },\n      // callback that returns true if event's\n      // modifier keys match the expected state\n      matchModifiers: function(event){},\n    }\n*/\n\nimport keycode from '../map/keycode';\n\nconst modifier = {\n  alt: 'altKey',\n  ctrl: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey',\n};\n\nconst modifierSequence = Object.keys(modifier).map(name => modifier[name]);\n\nfunction createExpectedModifiers(ignoreModifiers) {\n  const value = ignoreModifiers ? null : false;\n  return {\n    altKey: value,\n    ctrlKey: value,\n    metaKey: value,\n    shiftKey: value,\n  };\n}\n\nfunction resolveModifiers(modifiers) {\n  const ignoreModifiers = modifiers.indexOf('*') !== -1;\n  const expected = createExpectedModifiers(ignoreModifiers);\n\n  modifiers.forEach(function(token) {\n    if (token === '*') {\n      // we've already covered the all-in operator\n      return;\n    }\n\n    // we want the modifier pressed\n    let value = true;\n    const operator = token.slice(0, 1);\n    if (operator === '?') {\n      // we don't care if the modifier is pressed\n      value = null;\n    } else if (operator === '!') {\n      // we do not want the modifier pressed\n      value = false;\n    }\n\n    if (value !== true) {\n      // compensate for the modifier's operator\n      token = token.slice(1);\n    }\n\n    const propertyName = modifier[token];\n    if (!propertyName) {\n      throw new TypeError('Unknown modifier \"' + token + '\"');\n    }\n\n    expected[propertyName] = value;\n  });\n\n  return expected;\n}\n\nfunction resolveKey(key) {\n  const code = keycode[key] || parseInt(key, 10);\n  if (!code || typeof code !== 'number' || isNaN(code)) {\n    throw new TypeError('Unknown key \"' + key + '\"');\n  }\n\n  return [code].concat(keycode._alias[code] || []);\n}\n\nfunction matchModifiers(expected, event) {\n  // returns true on match\n  return !modifierSequence.some(function(prop) {\n    // returns true on mismatch\n    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];\n  });\n}\n\nexport default function(text) {\n  return text.split(/\\s+/).map(function(_text) {\n    const tokens = _text.split('+');\n    const _modifiers = resolveModifiers(tokens.slice(0, -1));\n    const _keyCodes = resolveKey(tokens.slice(-1));\n    return {\n      keyCodes: _keyCodes,\n      modifiers: _modifiers,\n      matchModifiers: matchModifiers.bind(null, _modifiers),\n    };\n  });\n}\n"]}