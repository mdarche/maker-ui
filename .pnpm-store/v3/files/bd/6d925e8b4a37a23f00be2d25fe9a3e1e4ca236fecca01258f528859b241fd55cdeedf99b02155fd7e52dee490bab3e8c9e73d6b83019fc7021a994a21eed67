{"version":3,"sources":["../../src/util/merge-dom-order.js"],"names":["list","elements","resolveElement","_list","slice","_elements","insertions","findInsertionOffsets","insertElementsAtOffsets","getFirstSuccessorOffset","target","element","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","forEach","replace","offset","indexOf","length","injections","push","inserted","sort","a","b","insertion","remove","args","concat","splice","apply"],"mappings":";;;;;;;;;;;;;;;;;;;oBAoFe,YAAgD;AAAA,mFAAJ,EAAI;AAAA,QAAtCA,IAAsC,QAAtCA,IAAsC;AAAA,QAAhCC,QAAgC,QAAhCA,QAAgC;AAAA,QAAtBC,cAAsB,QAAtBA,cAAsB;;AAC7D;AACA,QAAMC,QAAQH,KAAKI,KAAL,CAAW,CAAX,CAAd;AACA;AACA,QAAMC,YAAY,yBAAUJ,QAAV,EAAoBG,KAApB,CAA0B,CAA1B,CAAlB;AACA,gCAAaC,SAAb;AACA;AACA;AACA,QAAMC,aAAaC,qBAAqBJ,KAArB,EAA4BE,SAA5B,EAAuCH,cAAvC,CAAnB;AACA;AACAM,4BAAwBL,KAAxB,EAA+BG,UAA/B;AACA,WAAOH,KAAP;AACD,G;;;;;;;;;;;;;;AAxED,WAASM,uBAAT,CAAiCT,IAAjC,EAAuCU,MAAvC,EAA+C;AAC7C;AACA,WAAO,8BAAUV,IAAV,EAAgB,UAASW,OAAT,EAAkB;AACvC,aAAOD,OAAOE,uBAAP,CAA+BD,OAA/B,IAA0CE,KAAKC,2BAAtD;AACD,KAFM,CAAP;AAGD;AA5BD;;AAEA;;;;;;;;;;;;;;;;;AA4BA,WAASP,oBAAT,CAA8BP,IAA9B,EAAoCC,QAApC,EAA8CC,cAA9C,EAA8D;AAC5D;AACA;AACA,QAAMI,aAAa,EAAnB;AACAL,aAASc,OAAT,CAAiB,UAASJ,OAAT,EAAkB;AACjC,UAAIK,UAAU,IAAd;AACA,UAAIC,SAASjB,KAAKkB,OAAL,CAAaP,OAAb,CAAb;;AAEA,UAAIM,WAAW,CAAC,CAAhB,EAAmB;AACjB;AACAA,iBAASR,wBAAwBT,IAAxB,EAA8BW,OAA9B,CAAT;AACAK,kBAAU,KAAV;AACD;;AAED,UAAIC,WAAW,CAAC,CAAhB,EAAmB;AACjB;AACA;AACAA,iBAASjB,KAAKmB,MAAd;AACD;;AAED;AACA,UAAMC,aAAa,yBAAUlB,iBAAiBA,eAAeS,OAAf,CAAjB,GAA2CA,OAArD,CAAnB;AACA,UAAI,CAACS,WAAWD,MAAhB,EAAwB;AACtB;AACA;AACD;;AAEDb,iBAAWe,IAAX,CAAgB;AACdJ,sBADc;AAEdD,wBAFc;AAGdf,kBAAUmB;AAHI,OAAhB;AAKD,KA5BD;;AA8BA,WAAOd,UAAP;AACD;;AAED,WAASE,uBAAT,CAAiCR,IAAjC,EAAuCM,UAAvC,EAAmD;AACjD;AACA;AACA,QAAIgB,WAAW,CAAf;AACA;AACA;AACAhB,eAAWiB,IAAX,CAAgB,UAACC,CAAD,EAAIC,CAAJ;AAAA,aAAUD,EAAEP,MAAF,GAAWQ,EAAER,MAAvB;AAAA,KAAhB;AACAX,eAAWS,OAAX,CAAmB,UAASW,SAAT,EAAoB;AACrC;AACA,UAAMC,SAASD,UAAUV,OAAV,GAAoB,CAApB,GAAwB,CAAvC;AACA,UAAMY,OAAO,CAACF,UAAUT,MAAV,GAAmBK,QAApB,EAA8BK,MAA9B,EAAsCE,MAAtC,CAA6CH,UAAUzB,QAAvD,CAAb;AACAD,WAAK8B,MAAL,CAAYC,KAAZ,CAAkB/B,IAAlB,EAAwB4B,IAAxB;AACAN,kBAAYI,UAAUzB,QAAV,CAAmBkB,MAAnB,GAA4BQ,MAAxC;AACD,KAND;AAOD","file":"merge-dom-order.js","sourcesContent":["\n// sort a list of elements into another list of elements in DOM order\n\n/*\n  USAGE:\n    mergeDomOrder({\n      // DOM ordered array of elements to use as base of merge\n      list: [],\n      // unordered array of elements to merge into base list\n      elements: [],\n      // callback function to resolve an element\n      resolveElement: function(element) {\n        // return null to skip\n        // return element to replace insertion\n        // return [element1, element2, â€¦] to replace insertion with multiple elements\n        return element;\n      },\n    })\n*/\n\nimport findIndex from '../util/array-find-index';\nimport nodeArray from './node-array';\nimport sortDomOrder from './sort-dom-order';\n\nfunction getFirstSuccessorOffset(list, target) {\n  // find the first element that comes AFTER the target element\n  return findIndex(list, function(element) {\n    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;\n  });\n}\n\nfunction findInsertionOffsets(list, elements, resolveElement) {\n  // instead of mutating the elements list directly, remember position and map\n  // to inject later, when we can do this more efficiently\n  const insertions = [];\n  elements.forEach(function(element) {\n    let replace = true;\n    let offset = list.indexOf(element);\n\n    if (offset === -1) {\n      // element is not in target list\n      offset = getFirstSuccessorOffset(list, element);\n      replace = false;\n    }\n\n    if (offset === -1) {\n      // there is no successor in the tabsequence,\n      // meaning the image must be the last element\n      offset = list.length;\n    }\n\n    // allow the consumer to replace the injected element\n    const injections = nodeArray(resolveElement ? resolveElement(element) : element);\n    if (!injections.length) {\n      // we can't inject zero elements\n      return;\n    }\n\n    insertions.push({\n      offset,\n      replace,\n      elements: injections,\n    });\n  });\n\n  return insertions;\n}\n\nfunction insertElementsAtOffsets(list, insertions) {\n  // remember the number of elements we have already injected\n  // so we account for the caused index offset\n  let inserted = 0;\n  // make sure that we insert the elements in sequence,\n  // otherwise the offset compensation won't work\n  insertions.sort((a, b) => a.offset - b.offset);\n  insertions.forEach(function(insertion) {\n    // array.splice has an annoying function signature :(\n    const remove = insertion.replace ? 1 : 0;\n    const args = [insertion.offset + inserted, remove].concat(insertion.elements);\n    list.splice.apply(list, args);\n    inserted += insertion.elements.length - remove;\n  });\n}\n\nexport default function({list, elements, resolveElement} = {}) {\n  // operate on a copy so we don't mutate the original array\n  const _list = list.slice(0);\n  // make sure the elements we're injecting are provided in DOM order\n  const _elements = nodeArray(elements).slice(0);\n  sortDomOrder(_elements);\n  // find the offsets within the target array (list) at which to inject\n  // each individual element (from elements)\n  const insertions = findInsertionOffsets(_list, _elements, resolveElement);\n  // actually inject the elements into the target array at the identified positions\n  insertElementsAtOffsets(_list, insertions);\n  return _list;\n}\n"]}