{"version":3,"sources":["../../src/query/tabsequence.sort-tabindex.js"],"names":["elements","map","indexes","normal","filter","element","tabIndex","undefined","push","_elements","sort","reduceRight","previous","current","concat"],"mappings":";;;;;;;;;;;;;;;;;;;oBAGe,UAASA,QAAT,EAAmB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAMC,MAAM,EAAZ;AACA,QAAMC,UAAU,EAAhB;AACA,QAAMC,SAASH,SAASI,MAAT,CAAgB,UAASC,OAAT,EAAkB;AAC/C;AACA,UAAIC,WAAWD,QAAQC,QAAvB;AACA,UAAIA,aAAaC,SAAjB,EAA4B;AAC1BD,mBAAW,6BAAcD,OAAd,CAAX;AACD;;AAED;AACA,UAAIC,YAAY,CAAZ,IAAiBA,aAAa,IAA9B,IAAsCA,aAAaC,SAAvD,EAAkE;AAChE,eAAO,IAAP;AACD;;AAED,UAAI,CAACN,IAAIK,QAAJ,CAAL,EAAoB;AAClB;AACAL,YAAIK,QAAJ,IAAgB,EAAhB;AACA;AACAJ,gBAAQM,IAAR,CAAaF,QAAb;AACD;;AAED;AACAL,UAAIK,QAAJ,EAAcE,IAAd,CAAmBH,OAAnB;AACA;AACA,aAAO,KAAP;AACD,KAvBc,CAAf;;AAyBA;AACA;AACA;AACA,QAAMI,YAAYP,QAAQQ,IAAR,GAAeT,GAAf,CAAmB,UAASK,QAAT,EAAmB;AACtD,aAAOL,IAAIK,QAAJ,CAAP;AACD,KAFiB,EAEfK,WAFe,CAEH,UAASC,QAAT,EAAmBC,OAAnB,EAA4B;AACzC,aAAOA,QAAQC,MAAR,CAAeF,QAAf,CAAP;AACD,KAJiB,EAIfT,MAJe,CAAlB;;AAMA,WAAOM,SAAP;AACD,G","file":"tabsequence.sort-tabindex.js","sourcesContent":["\nimport tabindexValue from '../util/tabindex-value';\n\nexport default function(elements) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex\n  // elements with tabIndex \"0\" (including tabbableElements without tabIndex) should be navigated in the order they appear.\n  // elements with a positive tabIndex:\n  //   Elements that have identical tabIndexes should be navigated in the order they appear.\n  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.\n\n  // NOTE: sort implementation may be unstable and thus mess up DOM order,\n  // that's why we build a map that's being sorted instead. If we were able to rely\n  // on a stable sorting algorithm, sortTabindex() could be as simple as\n  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });\n  // at this time Chrome does not use a stable sorting algorithm\n  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability\n\n  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition\n\n  const map = {};\n  const indexes = [];\n  const normal = elements.filter(function(element) {\n    // in Trident and Gecko SVGElement does not know about the tabIndex property\n    let tabIndex = element.tabIndex;\n    if (tabIndex === undefined) {\n      tabIndex = tabindexValue(element);\n    }\n\n    // extract elements that don't need sorting\n    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {\n      return true;\n    }\n\n    if (!map[tabIndex]) {\n      // create sortable bucket for dom-order-preservation of elements with the same tabIndex\n      map[tabIndex] = [];\n      // maintain a list of unique tabIndexes\n      indexes.push(tabIndex);\n    }\n\n    // sort element into the proper bucket\n    map[tabIndex].push(element);\n    // element moved to sorting map, so not \"normal\" anymore\n    return false;\n  });\n\n  // sort the tabindex ascending,\n  // then resolve them to their appropriate buckets,\n  // then flatten the array of arrays to an array\n  const _elements = indexes.sort().map(function(tabIndex) {\n    return map[tabIndex];\n  }).reduceRight(function(previous, current) {\n    return current.concat(previous);\n  }, normal);\n\n  return _elements;\n}\n"]}