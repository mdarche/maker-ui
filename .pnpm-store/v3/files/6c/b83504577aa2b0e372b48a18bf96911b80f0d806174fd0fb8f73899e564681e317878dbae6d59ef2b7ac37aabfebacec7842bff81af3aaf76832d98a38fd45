{"version":3,"sources":["../../src/util/visible-area.js"],"names":["element","_element","getBoundingClientRect","_viewport","getViewportRect","area","width","height","_area","_container","getScrollableParentRect","getIntersectingRect","_visible","maxArea","Math","min","visibleArea","round","factor","roundedVisibleArea","one","two","top","max","left","right","bottom","window","innerWidth","document","documentElement","clientWidth","innerHeight","clientHeight","getInnerBoundingClientRect","rect","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","_rect","isOverflowingElement","style","getComputedStyle","value","getPropertyValue","isScrollableElement","scrollHeight","scrollWidth","scrollingContainers","context","slice","filter","length","reduce","previous","current","intersection"],"mappings":";;;;;;;;;;;;;;;;;;;oBAoGe,UAASA,OAAT,EAAkB;AAC/B;AACA,QAAMC,WAAWD,QAAQE,qBAAR,EAAjB;AACA;AACA,QAAMC,YAAYC,iBAAlB;AACA;AACAD,cAAUE,IAAV,GAAiBF,UAAUG,KAAV,GAAkBH,UAAUI,MAA7C;;AAEA,QAAIC,QAAQL,SAAZ;AACA;AACA,QAAMM,aAAaC,wBAAwBV,OAAxB,CAAnB;AACA,QAAIS,UAAJ,EAAgB;AACd,UAAI,CAACA,WAAWH,KAAZ,IAAqB,CAACG,WAAWF,MAArC,EAA6C;AAC3C;AACA;AACA,eAAO,CAAP;AACD;;AAED;AACAC,cAAQG,oBAAoBF,UAApB,EAAgCN,SAAhC,CAAR;AACAK,YAAMH,IAAN,GAAaI,WAAWJ,IAAxB;AACD;;AAED;AACA,QAAMO,WAAWD,oBAAoBV,QAApB,EAA8BO,KAA9B,CAAjB;AACA,QAAI,CAACI,SAASN,KAAV,IAAmB,CAACM,SAASL,MAAjC,EAAyC;AACvC;AACA,aAAO,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA,QAAMF,OAAOJ,SAASK,KAAT,GAAiBL,SAASM,MAAvC;AACA,QAAMM,UAAUC,KAAKC,GAAL,CAASV,IAAT,EAAeG,MAAMH,IAArB,CAAhB;AACA;AACA,QAAMW,cAAcF,KAAKG,KAAL,CAAWL,SAASN,KAApB,IAA6BQ,KAAKG,KAAL,CAAWL,SAASL,MAApB,CAA7B,GAA2DM,OAA/E;AACA;AACA,QAAMK,SAAS,KAAf;AACA,QAAMC,qBAAqBL,KAAKG,KAAL,CAAWD,cAAcE,MAAzB,IAAmCA,MAA9D;AACA;AACA,WAAOJ,KAAKC,GAAL,CAASI,kBAAT,EAA6B,CAA7B,CAAP;AACD,G;;;;;;;;;;AA5ID,WAASR,mBAAT,CAA6BS,GAA7B,EAAkCC,GAAlC,EAAuC;AACrC;AACA,QAAMC,MAAMR,KAAKS,GAAL,CAASH,IAAIE,GAAb,EAAkBD,IAAIC,GAAtB,CAAZ;AACA,QAAME,OAAOV,KAAKS,GAAL,CAASH,IAAII,IAAb,EAAmBH,IAAIG,IAAvB,CAAb;AACA;AACA,QAAMC,QAAQX,KAAKS,GAAL,CAAST,KAAKC,GAAL,CAASK,IAAIK,KAAb,EAAoBJ,IAAII,KAAxB,CAAT,EAAyCD,IAAzC,CAAd;AACA,QAAME,SAASZ,KAAKS,GAAL,CAAST,KAAKC,GAAL,CAASK,IAAIM,MAAb,EAAqBL,IAAIK,MAAzB,CAAT,EAA2CJ,GAA3C,CAAf;AACA;AACA,WAAO;AACLA,WAAKA,GADA;AAELG,aAAOA,KAFF;AAGLC,cAAQA,MAHH;AAILF,YAAMA,IAJD;AAKLlB,aAAOmB,QAAQD,IALV;AAMLjB,cAAQmB,SAASJ;AANZ,KAAP;AAQD;;AAED,WAASlB,eAAT,GAA2B;AACzB,QAAME,QAAQqB,OAAOC,UAAP,IAAqBC,SAASC,eAAT,CAAyBC,WAA5D;AACA,QAAMxB,SAASoB,OAAOK,WAAP,IAAsBH,SAASC,eAAT,CAAyBG,YAA9D;AACA;AACA,WAAO;AACLX,WAAK,CADA;AAELG,aAAOnB,KAFF;AAGLoB,cAAQnB,MAHH;AAILiB,YAAM,CAJD;AAKLlB,aAAOA,KALF;AAMLC,cAAQA;AANH,KAAP;AAQD;;AAED,WAAS2B,0BAAT,CAAoClC,OAApC,EAA6C;AAC3C;AACA,QAAMmC,OAAOnC,QAAQE,qBAAR,EAAb;;AAEA;AACA;AACA;AACA,QAAMkC,iBAAiBpC,QAAQqC,WAAR,GAAsBrC,QAAQ+B,WAArD;AACA,QAAMO,kBAAkBtC,QAAQuC,YAAR,GAAuBvC,QAAQiC,YAAvD;AACA;AACA,QAAMO,QAAQ;AACZlB,WAAKa,KAAKb,GADE;AAEZE,YAAMW,KAAKX,IAFC;AAGZC,aAAOU,KAAKV,KAAL,GAAaW,cAHR;AAIZV,cAAQS,KAAKT,MAAL,GAAcY,eAJV;AAKZhC,aAAO6B,KAAK7B,KAAL,GAAa8B,cALR;AAMZ7B,cAAQ4B,KAAK5B,MAAL,GAAc+B,eANV;AAOZjC,YAAM;AAPM,KAAd;;AAUAmC,UAAMnC,IAAN,GAAamC,MAAMlC,KAAN,GAAckC,MAAMjC,MAAjC;AACA,WAAOiC,KAAP;AACD;;AAED,WAASC,oBAAT,CAA8BzC,OAA9B,EAAuC;AACrC,QAAM0C,QAAQf,OAAOgB,gBAAP,CAAwB3C,OAAxB,EAAiC,IAAjC,CAAd;AACA,QAAM4C,QAAQ,SAAd;AACA,WAAOF,MAAMG,gBAAN,CAAuB,YAAvB,MAAyCD,KAAzC,IACFF,MAAMG,gBAAN,CAAuB,YAAvB,MAAyCD,KAD9C;AAED;;AAED,WAASE,mBAAT,CAA6B9C,OAA7B,EAAsC;AACpC;AACA,QAAI,CAACyC,qBAAqBzC,OAArB,CAAL,EAAoC;AAClC,aAAO,KAAP;AACD;;AAED;AACA,WAAOA,QAAQuC,YAAR,GAAuBvC,QAAQ+C,YAA/B,IACF/C,QAAQqC,WAAR,GAAsBrC,QAAQgD,WADnC;AAED;;AAED,WAAStC,uBAAT,CAAiCV,OAAjC,EAA0C;AACxC;;AAEA;AACA,QAAMiD,sBAAsB,uBAAW,EAACC,SAASlD,OAAV,EAAX,EAA+BmD,KAA/B,CAAqC,CAArC,EAAwCC,MAAxC,CAA+CN,mBAA/C,CAA5B;;AAEA,QAAI,CAACG,oBAAoBI,MAAzB,EAAiC;AAC/B;AACA,aAAO,IAAP;AACD;;AAED;AACA,WAAOJ,oBAAoBK,MAApB,CAA2B,UAASC,QAAT,EAAmBC,OAAnB,EAA4B;AAC5D,UAAMrB,OAAOD,2BAA2BsB,OAA3B,CAAb;AACA,UAAMC,eAAe9C,oBAAoBwB,IAApB,EAA0BoB,QAA1B,CAArB;AACA;AACA;AACA;AACAE,mBAAapD,IAAb,GAAoBS,KAAKC,GAAL,CAASoB,KAAK9B,IAAd,EAAoBkD,SAASlD,IAA7B,CAApB;AACA,aAAOoD,YAAP;AACD,KARM,EAQJvB,2BAA2Be,oBAAoB,CAApB,CAA3B,CARI,CAAP;AASD","file":"visible-area.js","sourcesContent":["\nimport getParents from '../get/parents';\n\nfunction getIntersectingRect(one, two) {\n  // identify the rectangle that _element and _container overlap in\n  const top = Math.max(one.top, two.top);\n  const left = Math.max(one.left, two.left);\n  // make sure bottom can't be above top, right can't be before left\n  const right = Math.max(Math.min(one.right, two.right), left);\n  const bottom = Math.max(Math.min(one.bottom, two.bottom), top);\n  // return something resembling ClientRect\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n\nfunction getViewportRect() {\n  const width = window.innerWidth || document.documentElement.clientWidth;\n  const height = window.innerHeight || document.documentElement.clientHeight;\n  // return something resembling ClientRect\n  return {\n    top: 0,\n    right: width,\n    bottom: height,\n    left: 0,\n    width: width,\n    height: height,\n  };\n}\n\nfunction getInnerBoundingClientRect(element) {\n  // convenience for the .reduce() in getScrollableParentRect()\n  const rect = element.getBoundingClientRect();\n\n  // remove the width of the scrollbar because that\n  // area is not really considered visible\n  // NOTE: assuming scrollbar is always to the right and bottom\n  const scrollbarWidth = element.offsetWidth - element.clientWidth;\n  const scrollbarHeight = element.offsetHeight - element.clientHeight;\n  // cannot mutate rect because it has readonly properties\n  const _rect = {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right - scrollbarWidth,\n    bottom: rect.bottom - scrollbarHeight,\n    width: rect.width - scrollbarWidth,\n    height: rect.height - scrollbarHeight,\n    area: 0,\n  };\n\n  _rect.area = _rect.width * _rect.height;\n  return _rect;\n}\n\nfunction isOverflowingElement(element) {\n  const style = window.getComputedStyle(element, null);\n  const value = 'visible';\n  return style.getPropertyValue('overflow-x') !== value\n    && style.getPropertyValue('overflow-y') !== value;\n}\n\nfunction isScrollableElement(element) {\n  // an element not scrollable if it doesn't crop its content\n  if (!isOverflowingElement(element)) {\n    return false;\n  }\n\n  // an element is scrollable when it is smaller than its content\n  return element.offsetHeight < element.scrollHeight\n    || element.offsetWidth < element.scrollWidth;\n}\n\nfunction getScrollableParentRect(element) {\n  // get largest possible space constrained by scrolling containers\n\n  // find scrollable parents\n  const scrollingContainers = getParents({context: element}).slice(1).filter(isScrollableElement);\n\n  if (!scrollingContainers.length) {\n    // no containers, no joy\n    return null;\n  }\n\n  // identify the currently visible intersection of all scrolling container parents\n  return scrollingContainers.reduce(function(previous, current) {\n    const rect = getInnerBoundingClientRect(current);\n    const intersection = getIntersectingRect(rect, previous);\n    // identify the smallest scrolling container so we know how much space\n    // our element can fill at the most - note that this is NOT the area\n    // of the intersection, intersection is just abused as a vehicle\n    intersection.area = Math.min(rect.area, previous.area);\n    return intersection;\n  }, getInnerBoundingClientRect(scrollingContainers[0]));\n}\n\nexport default function(element) {\n  // dimensions of the element itself\n  const _element = element.getBoundingClientRect();\n  // dimensions of the viewport\n  const _viewport = getViewportRect();\n  // we need the area to know how much of the element can be displayed at the most\n  _viewport.area = _viewport.width * _viewport.height;\n\n  let _area = _viewport;\n  // dimensions of the intersection of all scrollable parents\n  const _container = getScrollableParentRect(element);\n  if (_container) {\n    if (!_container.width || !_container.height) {\n      // scrollable containers without dimensions are invisible,\n      // meaning that the element is not visible at all\n      return 0;\n    }\n\n    // dimension the element can currently be rendered in\n    _area = getIntersectingRect(_container, _viewport);\n    _area.area = _container.area;\n  }\n\n  // dimension of the element currently rendered in identified space\n  const _visible = getIntersectingRect(_element, _area);\n  if (!_visible.width || !_visible.height) {\n    // element is not shown within the identified area\n    return 0;\n  }\n\n  // compare the element's currently visible size to the size it\n  // could take up at the most, being either the element's actual\n  // size, or the space theroetically made available if all\n  // scrollable parents are aligned properly\n  const area = _element.width * _element.height;\n  const maxArea = Math.min(area, _area.area);\n  // Firefox may return sub-pixel bounding client rect\n  const visibleArea = Math.round(_visible.width) * Math.round(_visible.height) / maxArea;\n  // Edge might not reach 0.5 exactly\n  const factor = 10000;\n  const roundedVisibleArea = Math.round(visibleArea * factor) / factor;\n  // clamp the value at 1\n  return Math.min(roundedVisibleArea, 1);\n}\n"]}