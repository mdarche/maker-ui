{"version":3,"sources":["../../src/query/tabsequence.sort-shadowed.js"],"names":["elements","context","sortElements","shadows","Shadows","_elements","extractElements","length","sort","hostCounter","inHost","inDocument","hosts","host","_sortingId","parentHost","_registerHost","_registerHostParent","push","parent","element","filter","_registerElement","_injectHosts","_replaceHosts","_cleanup","Object","keys","forEach","_list","_context","shadowRoot","_merge","list","merged","resolveElement","_resolveHostElement","bind","_tabindex","concat","key"],"mappings":"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","file":"tabsequence.sort-shadowed.js","sourcesContent":["\nimport getShadowHost from '../get/shadow-host';\nimport mergeInDomOrder from '../util/merge-dom-order';\nimport tabindexValue from '../util/tabindex-value';\n\nclass Shadows {\n  constructor(context, sortElements) {\n    // document context we're working with\n    this.context = context;\n    // callback that sorts an array of elements\n    this.sortElements = sortElements;\n    // reference to create unique IDs for each ShadowHost\n    this.hostCounter = 1;\n    // reference map for child-ShadowHosts of a ShadowHost\n    this.inHost = {};\n    // reference map for child-ShadowHost of the document\n    this.inDocument = [];\n    // reference map for ShadowHosts\n    this.hosts = {};\n    // reference map for tabbable elements of a ShadowHost\n    this.elements = {};\n  }\n\n  // remember which hosts we have to sort within later\n  _registerHost(host) {\n    if (host._sortingId) {\n      return;\n    }\n\n    // make the ShadowHost identifiable (see cleanup() for undo)\n    host._sortingId = 'shadow-' + (this.hostCounter++);\n    this.hosts[host._sortingId] = host;\n\n    // hosts may contain other hosts\n    const parentHost = getShadowHost({context: host});\n    if (parentHost) {\n      this._registerHost(parentHost);\n      this._registerHostParent(host, parentHost);\n    } else {\n      this.inDocument.push(host);\n    }\n  }\n\n  // remember which host is the child of which other host\n  _registerHostParent(host, parent) {\n    if (!this.inHost[parent._sortingId]) {\n      this.inHost[parent._sortingId] = [];\n    }\n\n    this.inHost[parent._sortingId].push(host);\n  }\n\n  // remember which elements a host contains\n  _registerElement(element, host) {\n    if (!this.elements[host._sortingId]) {\n      this.elements[host._sortingId] = [];\n    }\n\n    this.elements[host._sortingId].push(element);\n  }\n\n  // remove shadowed elements from the sequence and register\n  // the ShadowHosts they belong to so we know what to sort\n  // later on\n  extractElements(elements) {\n    return elements.filter(function(element) {\n      const host = getShadowHost({ context: element });\n      if (!host) {\n        return true;\n      }\n\n      this._registerHost(host);\n      this._registerElement(element, host);\n      return false;\n    }, this);\n  }\n\n  // inject hosts into the sequence, sort everything,\n  // and recoursively replace hosts by its descendants\n  sort(elements) {\n    let _elements = this._injectHosts(elements);\n    _elements = this._replaceHosts(_elements);\n    this._cleanup();\n    return _elements;\n  }\n\n  // merge ShadowHosts into the element lists of other ShadowHosts\n  // or the document, then sort the individual lists\n  _injectHosts(elements) {\n    Object.keys(this.hosts).forEach(function(_sortingId) {\n      const _list = this.elements[_sortingId];\n      const _elements = this.inHost[_sortingId];\n      const _context = this.hosts[_sortingId].shadowRoot;\n      this.elements[_sortingId] = this._merge(_list, _elements, _context);\n    }, this);\n\n    return this._merge(elements, this.inDocument, this.context);\n  }\n\n  _merge(list, elements, context) {\n    const merged = mergeInDomOrder({\n      list,\n      elements,\n    });\n\n    return this.sortElements(merged, context);\n  }\n\n  _replaceHosts(elements) {\n    return mergeInDomOrder({\n      list: elements,\n      elements: this.inDocument,\n      resolveElement: this._resolveHostElement.bind(this),\n    });\n  }\n\n  _resolveHostElement(host) {\n    const merged = mergeInDomOrder({\n      list: this.elements[host._sortingId],\n      elements: this.inHost[host._sortingId],\n      resolveElement: this._resolveHostElement.bind(this),\n    });\n\n    const _tabindex = tabindexValue(host);\n    if (_tabindex !== null && _tabindex > -1) {\n      return [host].concat(merged);\n    }\n\n    return merged;\n  }\n\n  _cleanup() {\n    // remove those identifers we put on the ShadowHost to avoid using Map()\n    Object.keys(this.hosts).forEach(function(key) {\n      delete this.hosts[key]._sortingId;\n    }, this);\n  }\n}\n\nexport default function(elements, context, sortElements) {\n  const shadows = new Shadows(context, sortElements);\n  const _elements = shadows.extractElements(elements);\n\n  if (_elements.length === elements.length) {\n    // no shadowed content found, no need to continue\n    return sortElements(elements);\n  }\n\n  return shadows.sort(_elements);\n}\n"]}